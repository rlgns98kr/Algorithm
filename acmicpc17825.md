# 주사위 윷놀이

https://www.acmicpc.net/problem/17825

## 개요

1~5까지 나오는 주사위를 던져 나온 수들이 10개 주어진다. 게임 말 4개를 말판에 옮길 때마다 점수가 추가되는데 최대 점수를 구하면 되는 문제.

![image](https://upload.acmicpc.net/82043a7c-75ea-46cd-9eaa-10aee52c0fce/-/preview/)

## 분석

주사위로 어떤 말들을 옮길지를 생각한다면 4^10의 조합은 중복되는 부분이 있어 비효율적이다. 예를 들어, 0000000000과 3333333333은 완벽히 똑같은 이동이고 이러한 이동은 4가지이다. 또한 0011223300의 경우 똑같은 이동이 4!만큼 있다. 이러한 중복을 제거하기 위해서는 새로 놓아지는 말들의 순서가 오름차순인 경우만을 따지면 될 것이다. DFS로 구현한다면 순서대로 새로운 말을 내놓을 것인지(2개의 말이 놓아져 있다면 3번 말이 나가야함), 기존 말들 중 선택할 것(값이 있는 말들만 재귀)인지의 가지로 뻗어 가면 중복되지 않는 경우만을 검사할 수 있다.

조합을 선택하는 문제를 해결한다면 현재 말들의 위치가 겹치는 지 검사해 주어야한다. 주사위 눈금의 수와 현재이동하고 있는 경로 두가지 변수를 이용하여 검사하면 되지만 조금 더 간단한 구현은 말판마다 고유한 숫자를 부여하여 체크해주는 것이다.

## 알고리즘

1. 배열에 말판을 저장한다.(갈랫길 4개의 배열)

2. 4진법을 이용하여 0\~4^10-1(0000000000\~3333333333)만큼 반복한다.

3. 각 자리수 별로 0, 1, 2, 3을 각 말들로 가정한다.

4. 각 말들을 이동시키며 주사위의 수의 합과 말판의 숫자를 이용하여 가능한 조합인지 검사한다.(이미 말이 있으면 다른 말을 놓을 수 없음)

5. 가능하다면 max값과 비교하여 갱신한다.

## 소스

```c
#include <stdio.h>
#include <math.h>

int ac[4][25] = { {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 0, 0, 0, 0}, {0, 2, 4, 6, 8, 10, 13, 16, 19, 25, 30, 35, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25, 30, 35, 40, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 28, 27, 26, 25, 30, 35, 40, 0, 0}};
int ss[11], ju[11], aa[4][2], chkk[4];
// a b c d 20
// a e 12
// a b f 
// a b c g


int main()
{
	int  sum, max=0, i, j, k, l,chk, a;
	for (i = 1; i <= 10; i++) scanf("%d", &ju[i]);
	l = pow(4, 10);
	for (k = 0; k < l; k++)
	{
		a = k;
		for (i = 1; i <= 10; i++)
		{
			
			if (a % 4 == 0) ss[i] = 0;
			if (a % 4 == 1) ss[i] = 1;
			if (a % 4 == 2) ss[i] = 2;
			if (a % 4 == 3) ss[i] = 3;
			a /= 4;
		}

		sum = 0;
		chk = 0;
		for (i = 0; i < 4; i++)
		{
			aa[i][0] = 0;
			aa[i][1] = 0;
			chkk[i] = 0;
		}

		for (i = 1; i <= 10; i++)
		{
			aa[ss[i]][0] += ju[i];
			
			if (aa[ss[i]][0] > 24) chk = 1;

			if (aa[ss[i]][1] == 0)
			{
				for (j = 1; j < 4; j++)
				{
					if (aa[ss[i]][0] == j * 5) aa[ss[i]][1] = j;
				}
			}

			for (j = 0; j < 4; j++)
			{
				if (j != ss[i])
				{
					if (aa[ss[i]][0] == aa[j][0] && aa[ss[i]][1]==aa[j][1] ) chk = 1;

					if (ac[aa[ss[i]][1]][aa[ss[i]][0]] == 25 && ac[aa[j][1]][aa[j][0]] == 25) chk = 1;
					else if (ac[aa[ss[i]][1]][aa[ss[i]][0]] == 30 && ac[aa[j][1]][aa[j][0]] == 30 && ac[aa[ss[i]][1]][aa[ss[i]][0] + 1] == 35 && ac[aa[j][1]][aa[j][0] + 1] == 35) chk = 1;
					else if (ac[aa[ss[i]][1]][aa[ss[i]][0]] == 35 && ac[aa[j][1]][aa[j][0]] == 35) chk = 1;
					else if (ac[aa[ss[i]][1]][aa[ss[i]][0]] == 40 && ac[aa[j][1]][aa[j][0]] == 40) chk = 1;
				}
			}
			if (chk == 1) break;

			

			if (chk == 1) break;

			sum += ac[aa[ss[i]][1]][aa[ss[i]][0]];
		}
		if (chk == 1)
		{
			continue;
		}
		if (max < sum)
		{
			max = sum;
		}
	}
	printf("%d", max);
}
```

